extends ../../main.pug

block content

  h1 Modules

  - function ref_grammar(sym) { return base_url + '/manual/syntax#' + sym }

  p.
    A module is the smallest unit of compilation.

  p.
    It consists of a declaration of its name,
    a set of declarations of imported modules,
    and a set of global name bindings:

  pre.
      module example;

      import lib1;
      import lib2 as l2;

      main = lib1.alpha + l2.beta;

  p See #[a(href=ref_grammar('module')) Grammar: module]

  h2 Default module name

  p.
    The module name declaration is optional.
    If it is missing, the module gets the default name "m".

  h2 Imported modules

  p.
    A module import declaration causes the imported module to be compiled,
    and the global names in that module become available in the current
    module.

  p.
     The imported module must reside in a file named "module-name.arrp".
     The file must either be adjacent to the location of the importing module,
     or in one of the #[i import directories] given as an option to the compiler.

  h2 Accessing imported names using qualified identifiers

  p.
    The names in the imported module are available in the importing module
    using qualified identifiers
    (see #[a(href=ref_grammar('qualified-id')) Grammar: qualified-id]):


  h2 The "main" expression

  p.
    The main module being compiled must contain an expression named "main"
    which represents the entire program.



  h1 Name bindings and functions

  p.
    Global bindings bind names to functions or constant expressions:

  pre.
    pi = 3.14159265359;

    area_of_circle(r) = pi * r * r;

    area_of_right_triangle(a, b) = a * b / 2;

  p See #[a(href=ref_grammar('bindings')) Grammar: bindings]

  h2 Function application

  p A function is applied when followed by arguments in parenthesis:

  pre.
    area_of_right_triangle(a, b) = a * b / 2;

    main = #[b area_of_right_triangle(10, 5)];

  p See #[a(href=ref_grammar('func-application')) Grammar: func-application]

  h2 Function polymorphism

  p.
    All functions are polymorphic: they can be applied to arguments of
    any type consistent with the expression of the function.

  // TODO: add example

  h2 Scope of global names

  p.
    The scope of a global name is the expression to which it is bound,
    and the expressions of the following global names.

  h2 Local name bindings

  p.
    Names with scope local to an expresion can be bound using the
    "let" and "where" expressions:

  pre.
    f(x) = #[b let] y = x * x #[b in] sin(y) + cos(y);

    g(x) = sin(y) + cos(y) #[b where] y = x * x;

  p.
    See #[a(href=ref_grammar('let-expr')) Grammar: let-expr],
    #[a(href=ref_grammar('where-expr')) Grammar: where-expr]

  h2 Lambda functions

  p.
    An unnamed function (a "lambda abstraction") can be defined
    as part of another expression:

  pre.
    f(g) = g(1,2) + g(3,4);

    main = f(#[b \x, y -> x * y]);

  p See #[a(href=ref_grammar('lambda')) Grammar: lambda].

  h2 Recursion

  p.
    Recursion is allowed for the purpose of recursive arrays. However,
    recursive use of functions is not supported. Some common uses
    of functional recursion can be achieved with recursive arrays.
    See #[a(href='#recursive-arrays') Recursive arrays].


  h1 Arrays



  h1 Literal primitive values

  pre.
    int

    real

    complex

    boolean

  p See #[a(href=ref_grammar('literal')) Grammar: literal]

  h1 Built-in operations and functions

  h2 Unary and binary operators

  pre.
    expr += unary-op expr | expr binary-op expr

    unary-op = "!" | "-"

    binary-op =
        "||" | "&&" | "==" | "!=" | "<" | "<=" | ">" | ">=" |
        "+" | "-" | "*" | "/" | "//" | "%" | "^"

  ul
    li "!", "||", "&&" - Boolean negation, disjunction and conjunction.
    li "==", "!=" - Equivalence and Inequivalence (boolean or numerical).
    li "<", "<=", ">", ">=" - Numerical comparison.
    li.
      "+", "-", "*", "/", "//" - Arithmetic.
      "/" is always a floating point division, and "//" is always an integer division.
    li "%" Remainder.
    li "^" Exponentiation.


  h2 Math Functions

  pre.
    exp, exp2, log, log2, log10,
    sqrt, sin, cos, tan, asin, acos, atan,
    ceil, floor, abs, min, max

  h2 Complex numbers

  p Accessing real and imaginary part of a complex number:

  pre real, imag

  h2 Type conversion

  pre real32, real64, complex32, complex64.

  h1 Broadcasting


